"""Hook subcommand for OpenCode session tracking.

Called by an OpenCode plugin event bridge to maintain a windowâ†”session
mapping in <OOBOT_DIR>/session_map.json. Also provides `--install` to
install that plugin into OpenCode's global plugins directory.

This module must NOT import config.py (which requires TELEGRAM_BOT_TOKEN),
since hooks run inside tmux panes where bot env vars are not set.
Config directory resolution uses utils.oobot_dir() (shared with config.py).

Key functions: hook_main() (CLI entry), _install_hook().
"""

import argparse
import fcntl
import json
import logging
import os
import re
import shutil
import subprocess
import sys
from pathlib import Path

logger = logging.getLogger(__name__)

# Validate session_id (OpenCode uses `ses_...`; keep UUID compatibility)
_UUID_RE = re.compile(r"^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")
_SES_RE = re.compile(r"^ses_[A-Za-z0-9_-]+$")

_OPENCODE_PLUGIN_DIR = Path.home() / ".config" / "opencode" / "plugins"
_HOOK_PLUGIN_FILE = _OPENCODE_PLUGIN_DIR / "oobot-session-map.js"

_PLUGIN_SENTINEL = "// Generated by oobot hook --install"


def _find_oobot_path() -> str:
    """Find the full path to the oobot executable.

    Priority:
    1. shutil.which("oobot") - if oobot is in PATH
    2. Same directory as the Python interpreter (for venv installs)
    """
    # Try PATH first
    oobot_path = shutil.which("oobot")
    if oobot_path:
        return oobot_path

    # Fall back to the directory containing the Python interpreter
    # This handles the case where oobot is installed in a venv
    python_dir = Path(sys.executable).parent
    oobot_in_venv = python_dir / "oobot"
    if oobot_in_venv.exists():
        return str(oobot_in_venv)

    # Last resort: assume it will be in PATH
    return "oobot"


def _render_bridge_plugin(oobot_path: str, oobot_dir: str) -> str:
    """Render the OpenCode plugin that forwards session.created to oobot hook."""
    oobot_path_json = json.dumps(oobot_path)
    oobot_dir_json = json.dumps(oobot_dir)
    return (
        f"{_PLUGIN_SENTINEL}\n"
        'import { spawnSync } from "node:child_process"\n\n'
        "export const OOBotSessionMapPlugin = async () => {\n"
        "  return {\n"
        "    event: async ({ event }) => {\n"
        '      if (event?.type !== "session.created" && event?.type !== "session.updated") return\n'
        "      const info = event?.properties?.info ?? event?.properties ?? {}\n"
        "      const session_id = info.id ?? info.sessionID ?? info.sessionId ?? event?.sessionID ?? event?.id\n"
        "      const cwd = info.directory ?? info.cwd ?? event?.directory ?? event?.path?.cwd\n"
        "      if (!session_id || !cwd) return\n"
        "      const payload = {\n"
        '        hook_event_name: "SessionStart",\n'
        "        session_id,\n"
        "        cwd,\n"
        "      }\n"
        "      try {\n"
        "        const env = { ...process.env, OOBOT_DIR: "
        f"{oobot_dir_json} }}\n"
        f'        spawnSync({oobot_path_json}, ["hook"], {{\n'
        "          input: JSON.stringify(payload),\n"
        '          encoding: "utf8",\n'
        '          stdio: ["pipe", "ignore", "ignore"],\n'
        "          env,\n"
        "        })\n"
        "      } catch {\n"
        "        // Ignore plugin bridge errors to avoid interrupting OpenCode.\n"
        "      }\n"
        "    },\n"
        "  }\n"
        "}\n"
    )


def _cleanup_legacy_project_plugin() -> None:
    """Remove old project-local bridge if it was generated by oobot.

    Earlier versions installed to `./.opencode/plugins`.
    """
    plugin_file = Path.cwd() / ".opencode" / "plugins" / "oobot-session-map.js"
    if not plugin_file.exists():
        return

    try:
        content = plugin_file.read_text()
    except OSError as e:
        logger.warning("Failed to inspect legacy project bridge %s: %s", plugin_file, e)
        return

    if not content.startswith(_PLUGIN_SENTINEL):
        logger.info(
            "Legacy project plugin exists but is not oobot-generated: %s", plugin_file
        )
        return

    try:
        plugin_file.unlink()
    except OSError as e:
        logger.warning("Failed to remove legacy project bridge %s: %s", plugin_file, e)
        return

    logger.info("Removed legacy project hook bridge: %s", plugin_file)
    print(f"Removed legacy project hook bridge: {plugin_file}")


def _install_hook() -> int:
    """Install the oobot hook bridge plugin into OpenCode global plugins.

    Returns 0 on success, 1 on error.
    """
    plugin_file = _HOOK_PLUGIN_FILE
    plugin_file.parent.mkdir(parents=True, exist_ok=True)

    # Find the full path to oobot
    oobot_path = _find_oobot_path()
    from .utils import oobot_dir

    plugin_content = _render_bridge_plugin(oobot_path, str(oobot_dir().resolve()))

    # No-op if identical content is already installed.
    if plugin_file.exists():
        try:
            current = plugin_file.read_text()
            if current == plugin_content:
                logger.info("Hook bridge already installed in %s", plugin_file)
                print(f"Hook bridge already installed in {plugin_file}")
                return 0
        except OSError as e:
            logger.error("Error reading %s: %s", plugin_file, e)
            print(f"Error reading {plugin_file}: {e}", file=sys.stderr)
            return 1

    logger.info("Installing hook bridge plugin: %s", plugin_file)
    try:
        plugin_file.write_text(plugin_content)
    except OSError as e:
        logger.error("Error writing %s: %s", plugin_file, e)
        print(f"Error writing {plugin_file}: {e}", file=sys.stderr)
        return 1

    logger.info("Hook bridge installed successfully in %s", plugin_file)
    print(f"Hook bridge installed successfully in {plugin_file}")

    # Best-effort cleanup for old install location used by previous versions.
    _cleanup_legacy_project_plugin()
    return 0


def hook_main() -> None:
    """Process a OpenCode hook event from stdin, or install the hook."""
    # Configure logging for the hook subprocess (main.py logging doesn't apply here)
    logging.basicConfig(
        format="%(asctime)s [%(levelname)s] %(name)s: %(message)s",
        level=logging.DEBUG,
        stream=sys.stderr,
    )

    parser = argparse.ArgumentParser(
        prog="oobot hook",
        description="OpenCode session tracking hook",
    )
    parser.add_argument(
        "--install",
        action="store_true",
        help=(
            "Install the OpenCode plugin bridge for session tracking "
            "(~/.config/opencode/plugins/oobot-session-map.js)"
        ),
    )
    # Parse only known args to avoid conflicts with stdin JSON
    args, _ = parser.parse_known_args(sys.argv[2:])

    if args.install:
        logger.info("Hook install requested")
        sys.exit(_install_hook())

    # Normal hook processing: read JSON from stdin
    logger.debug("Processing hook event from stdin")
    try:
        payload = json.load(sys.stdin)
    except (json.JSONDecodeError, ValueError) as e:
        logger.warning("Failed to parse stdin JSON: %s", e)
        return

    session_id = payload.get("session_id", "")
    cwd = payload.get("cwd", "")
    event = payload.get("hook_event_name", "")

    if not session_id or not event:
        logger.debug("Empty session_id or event, ignoring")
        return

    # Validate session_id format (legacy UUID or current ses_ format)
    if not (_UUID_RE.match(session_id) or _SES_RE.match(session_id)):
        logger.warning("Invalid session_id format: %s", session_id)
        return

    # Validate cwd is an absolute path (if provided)
    if cwd and not os.path.isabs(cwd):
        logger.warning("cwd is not absolute: %s", cwd)
        return

    if event != "SessionStart":
        logger.debug("Ignoring non-SessionStart event: %s", event)
        return

    # Get tmux session:window key for the pane running this hook.
    # TMUX_PANE is set by tmux for every process inside a pane.
    pane_id = os.environ.get("TMUX_PANE", "")
    if not pane_id:
        logger.warning("TMUX_PANE not set, cannot determine window")
        return

    result = subprocess.run(
        [
            "tmux",
            "display-message",
            "-t",
            pane_id,
            "-p",
            "#{session_name}:#{window_name}",
        ],
        capture_output=True,
        text=True,
    )
    session_window_key = result.stdout.strip()
    if not session_window_key or ":" not in session_window_key:
        logger.warning("Failed to get session:window key from tmux (pane=%s)", pane_id)
        return

    logger.debug(
        "tmux key=%s, session_id=%s, cwd=%s", session_window_key, session_id, cwd
    )

    # Read-modify-write with file locking to prevent concurrent hook races
    from .utils import oobot_dir

    map_file = oobot_dir() / "session_map.json"
    map_file.parent.mkdir(parents=True, exist_ok=True)

    lock_path = map_file.with_suffix(".lock")
    try:
        with open(lock_path, "w") as lock_f:
            fcntl.flock(lock_f, fcntl.LOCK_EX)
            logger.debug("Acquired lock on %s", lock_path)
            try:
                session_map: dict[str, dict[str, str]] = {}
                if map_file.exists():
                    try:
                        session_map = json.loads(map_file.read_text())
                    except (json.JSONDecodeError, OSError):
                        logger.warning(
                            "Failed to read existing session_map, starting fresh"
                        )

                session_map[session_window_key] = {
                    "session_id": session_id,
                    "cwd": cwd,
                }

                from .utils import atomic_write_json

                atomic_write_json(map_file, session_map)
                logger.info(
                    "Updated session_map: %s -> session_id=%s, cwd=%s",
                    session_window_key,
                    session_id,
                    cwd,
                )
            finally:
                fcntl.flock(lock_f, fcntl.LOCK_UN)
    except OSError as e:
        logger.error("Failed to write session_map: %s", e)
